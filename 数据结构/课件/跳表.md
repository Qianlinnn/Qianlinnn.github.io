## 如何理解跳表

在链表中查找某个数据，只能从头到尾遍历链表，这样时间复杂度为O(n), 因此可以对链表建立一级"索引",每两个节点提取一个节点到上一级，我们把抽出来的那一级叫做索引或索引曾。如图所示

![1]()

* 假设要查16这个节点，那么首先遍历第一级索引，查到13时，下一级是17，因此从13再跳到原始链表，再继续遍历两个节点就到了16，此时只需要遍历7个节点，之前要遍历10个，因为查找所需数据的遍历结点个数减少了，因此效率变高。

接着我们可以设置第二级索引，如图所示

![2]()

为了更明显可以设置五级索引，如图所示：

![3]()

如图所示，之前搜62要遍历62次，现在只需要11次，这种链表加多级索引的结构就是跳表。

## 用跳表查询有多快

* 每两个节点会会抽出一个节点作为上一级索引的节点，那么第一季索引就是n/2, 第二级索引n/4,因此第k级索引的结点个数是第k-1级节点个数的1/2, 那第k级索引节点的个数就是n/(2^k)
* 假设索引有h级，最高级的索引有2个节点，因此我们可以得到n/(2^h) = 2, h = log2 (n-1)，如果每一层都遍历m个节点，那么查询一个数据的时间复杂度为O(m*logn)
* 按照上面的结构，每一级最多遍历3个，也就是说m = 3

![4]()

* 如图所示，我们要查找x，z> x >y,因此在第k-1级中，最多只需要遍历3个节点，因为y,z之间总共有3个节点
* 跳表是典型的空间换时间

## 跳表的空间复杂度分析

![5]()

* 总和可得 n-2,因此空间复杂度是O(n)

  * 如何降低空间复杂度？

* 可以选取每三个节点或者每五个节点来测试

  * 每三个节点的节点数为如图所示

    ![6]()

    * 总的节点数为n/2, 空间复杂度还是O(n),因此实际开发中我们不必太在意占用的额外空间

## 高效的动态插入和删除

* 链表的插入时间复杂度为O(1),但是在跳表中，为了保证原始链表数据的有序性，需要查找位置，因此时间复杂度也是O(logn)
* 删除操作除了原始链表的节点，如果该节点在索引中出现，也需要删除索引的。而且查找要删除的结点时，一定要获取前驱结点。 双向链表不需要考虑这个问题

## 跳表索引动态更新

* 如果往跳表中不停的插入数据，不更新索引的话，可能导致某2个索引节点之间数据非常多，极端情况，可能退化成单链表，如下图所示

  ![7]()

* 通过随机函数来维护平衡性

  * 当我们往跳表中加入数据的时候，可以选择同时将这个数据插入到部分索引层中。

  * 比如随机函数生成了值k，我们就将这个结点添加到第1级到第K级这K级索引中

    ![8]()

