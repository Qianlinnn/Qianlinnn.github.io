# 堆和堆排序

## 如何理解堆

* **特性1**：堆是一个完全二叉树
* **特性2**：堆中每一个结点的值都必须大于等于(或小于等于)其子树中每个节点的值

### 解释：

* 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列

* 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值

  ![1]()

* 第一个和第二个是大顶堆，第三个是小顶堆，第四个不是堆

## 如何实现一个堆

* 完全二叉树比较适合用数组来存储。主要是节省存储空间，不需要左右子节点的指针，纯粹用数组的下标就行
* ![2]()
  * 下标为i的节点的左子节点，下标为i * 2,右子节点就是下标i * 2  + 1的节点，父节点就是下标为i / 2的节点

### 1. 往堆中插入一个元素

![3]()

* 将新插入的元素放到堆的最后，会不符合堆的特性(特性2), 因此需要进行调整使其满足堆的特性，该过程叫堆化。堆化有**从下往上**和**从上往下**
* 堆化：顺着节点所在的路径，向上或者向下，对比，然后交换
* 堆化分解图如下所示： 如果不满足子节点小于等于父节点的大小关系，就互换两个节点，一直重复该过程

![4]()

### 2. 删除堆顶元素

* 由堆的第二条特性可知，堆顶元素存储的就是堆中数据的最大值或者最小值
  * 假设是大顶堆，堆顶元素就是最大的元素，当删除堆顶元素之后，需要把第二大的元素放到堆顶，第二大元素肯定会出现在左右子节点中，然后再迭代的删除第二大节点。
  * 下面有个分解图所示，但略有问题,会产生数组空洞：
    * ![5]()
  * 改善方法：把最后一个节点放到堆顶，然后同样利用父子对比方法，重复进行，这就是从上而下的堆化方法。因为移除的是最后一个元素，而堆化的过程中都是交换操作，因此肯定满足完全二叉树的特性
    * ![6]()
  * 时间复杂度： 一个包含n节点的完全二叉树，数的高度不会超过log2 n, 堆化是顺着节点所在路径比较交换，因此时间复杂度与树的高度成正比，即O(logn)

## 如何基于堆实现排序?

借助堆实现的排序算法，叫做堆排序，时间复杂度稳定，为O(nlogn),还是原地爱婿算法, 大致分解为两个大的步骤：建堆和排序

### 1. 建堆

* 思路1：在堆中插入一个元素的思路。尽管数组中包含n个数据，但可以假设初始只包含一个数据，下标为1的数据。然后调用前面的插入操作，从2到n的数据一次插入堆中这样就组织成了堆
* 思路2：步骤分解图：
  * ![7]()
  * ![8]()
  * 对下标从(n/2)到1的数据开始堆化，下标是(n/2)+1到n的节点是叶子节点，不需要堆化。**此堆化过程中，是不断的交换，一直比较到叶子节点**
  * 时间复杂度：O(n). 需要堆化的节点从倒数第二层开始。比较和交换的节点个数，跟这个节点的高度k成正比。如下图所示：
    * ![9]()
    * ![10]()
    * ![11]()
    * ![12]()
    * h = log(2 n).代入可得S = O(n)

### 2. 排序

* 已经按照大顶堆的特性来组织，因此数组中的第一个元素就是堆顶，也就是最大的元素，把它和最后一个元素交换，最大元素就放到了下表为n的位置。然后把现在的堆顶元素进行堆化操作，然后再取堆顶的元素跟下标为n-1的位置交换并继续堆化。直到最后堆中只剩下标为1的元素。排序工作就完成了

  ![13]()

* 堆排序的时间复杂度：O(nlogn), 不是稳定的排序算法。原地排序算法

* 那如果从 0 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。如果节点的下标是 i，那左子节点的下标就是 2∗i+1，右子节点的下标就是 2∗i+2，父节点的下标就是 2i−1。

## 在实际开发中，为什么快速排序要比堆排序性能好

* 第一点，堆排序数据访问的方式没有快速排序友好。
* 第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

