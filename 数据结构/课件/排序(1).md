## 排序算法时间复杂度比较

 ![1](C:\Github\personal-study-zone\数据结构\img\排序\1.png) ()

## 排序算法的执行效率

### 1 最好情况、最坏情况、平均情况时间复杂度

* 为了对比排序算法
* 知道排序算法在不同数据下的性能表现

### 2 时间复杂度的系数，常数，低阶

* 实际工程的数据集可能并不是数据很大的规模，此时，应该把上述这些参数考虑进来

### 3 比较次数和交换（或移动）次数

*  分析基于比较的排序算法，会有以下两种操作，元素比较大小和元素交换或移动。因此我们需要把比较次数和移动次数考虑进去

#### 排序算法的内存消耗

* 原地排序：特指空间复杂度为O(1)的排序算法以下的三个排序算法都是原地排序算法

#### 排序算法的稳定性

* 稳定性： 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变
  * 2，9，3，4，8，3 经过排序后如果两个3的前后顺序不变，那么就是稳定的排序算法
* 举例问题：们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？
  * 我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变**

## 冒泡排序

* 只操作相邻的两个数据，每次冒泡操作都会对相邻的两个元素进行比较大小关系，如果不满足就互换位置。重复n次就完成n个数据的排序工作。详细如图，数据为：4，5，6，3，2，1

  ​		![2](C:\Github\personal-study-zone\数据结构\img\排序\2.png)

  6已经排好了位置，进行6次冒泡操作就可以了

  ![3](C:\Github\personal-study-zone\数据结构\img\排序\3.png)

* 上述案例还可以优化，当某次冒泡操作已经没有数据交换时，说明已经达到了完全有序，不用再继续执行后续的冒泡操作。

* 三个结论：

  * 1 冒泡只需要常量级的临时空间，所以空间复杂度为O(1)，是一个原地排序算法

  * 2 两个元素大小相等的时候，不做交换，所以是稳定的排序算法

  * 3 时间复杂度 ，最好的情况下是只进行一次冒泡操作，即为O(n),最坏则是O(n^2),平均时间复杂度为加权平均期望时间复杂度。通过**有序度** 和**逆序度**来进行分析即：

    * 有序元素对：a[i] <= a[j], 如果i < j。

      ​	![4](C:\Github\personal-study-zone\数据结构\img\排序\4.png)

    * 完全有序的数组的有序度就是n*(n-1)/2,这种有序度叫做满有序度

    * 逆序度：逆序元素对：a[i] > a[j], 如果i < j。

    * **逆序度 = 满有序度 - 有序度**

  * 所以操作的次数即为该序列的逆序度。最坏的情况下为n*(n-1)/2次交换，最好是0次交换，所以取均值n*(n-1)/4平均复杂度就是O(n^2)

## 插入排序

插入排序举例: 遍历数组，找到数据应该插入的位置将其插入即可



![5](C:\Github\personal-study-zone\数据结构\img\排序\5.png)



* 将数据分为已排序区间和未排序区间，初始已排序区间只有一个元素，就是数组的第一个元素。该算法的核心思想是取未排序区间中的元素，在已排序区间找到合适的位置插入。并保证已排序区间一直有序。直到未排序区间中元素为空。
* 案例还是4，5，6，1，3，2，左侧为已排序区间，右侧是未排序区间
  * 也包含两种操作：元素的比较和元素的移动，把数据a插入到已排序区间时，拿a与已排序区间的元素依次比较，找到插入点后，还要讲插入点之后的元素顺序向后移动一位。
  *  移动次数等于逆序度
* 插入排序是原地排序算法。不需要额外的存储空间
* 对于值相同的元素，我们可以将豁免出现的元素插入到前面出现元素的后面，所以也是稳定的排序算法
* 从尾到头遍历已经有序的数据，最好的时间复杂度为O(n).如果是倒序的，则需要时间复杂度为O(n^2),平均时间复杂度为O(n^2):因为数组插入一个数据，时间复杂度为O(n),插入排序就是循环执行n次插入。

## 选择排序

也分为已排序区间和未排序区间。该算法会从未排序区间中找到最小的元素，将其放到已排序区间的结尾

![6](C:\Github\personal-study-zone\数据结构\img\排序\6.png)

* 空间复杂度为O(1)
* 选择排序的所有时间复杂度都为O(n^2)
* 不是稳定排序



解答开篇： 冒泡排序的数据交换有3个赋值操作，而插入排序只需要1个

