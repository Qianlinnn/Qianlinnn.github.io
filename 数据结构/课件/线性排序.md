# 线性排序(时间复杂度是线性的)

## 桶排序

* 核心思想： 将要排序的数据分到几个有序的桶里，每个桶里再单独排序，桶内排完序之后，再把每个桶里的数据按照顺序一次取出，组成的序列就是有序的了

  ![1]()

* 时间复杂度：排序的数据有n个，均匀的分到m个桶，每个桶里有k = n/m个元素。内部使用快速排序，时间复杂度为O(k*logk).m个桶的时间复杂度为O(m*k*logk), 所以整个桶排序的时间复杂度为O(n*log(n/m)).当桶的个数接近数据个数n时，log(n/m)就是一个非常小的常量，此时桶排序的时间复杂度接近O(n)

* 实际上不实用：

  * 需要很容易能划分成m个桶，，且桶与桶之间天然有大小顺序，这样桶内排序完之后，桶与桶之间的数据不再需要排序
  * 各个桶之间的分布比较均匀。因为如果数据分布不均，桶内数据排序的时间复杂度就不是常量级。如果被分到一个桶里，就被退化为O(nlogn)

* 桶排序适用于外部排序中(即没有办法将数据全部加载到内存中)

## 计数排序(难点)

* 计数排序其实是桶排序的一种特殊情况，当排序的数据有n个，但是范围并不大。比如最大值是k，我们就可以设置k个桶，每个桶内的数据值是相同的，省略了桶内排序的时间
* 由以上可知，省略了桶内排序，因此只有遍历才做，因此时间复杂度为O(n)
* 案例分析：
  * 8个学生分数在0-5之间，成绩分别为A = [2, 5, 3, 0, 2, 3, 0, 3]
  * 用C来表示桶，下标为对应分数 0,1,2,3,4,5,存储的值为考生人数(值的个数) C = [2,0,2,3,0,1]
  *  对C顺序求和可得C = [2, 2, 4, 7, 7, 8],存储得值是小于等于下标得值得个数
  * 令R为按照考生成绩的名次从小到大排序的结果，
  * 从后到前依次扫描A，得到3时，从数组C里取下标为4的数据值，得到7, 将3放入R的第7个(即下标为6的位置)，并将C[3]里的值减1(因为人数减少了1个), 取到0的时候，得到2，将0放到R的第二位，即下标为1的位置，并将C[0]减少1，依次类推，最后得到的就是从小到大排序的

![2]()

* 总结：计数排序只能用于数据范围不大的场景中，而且只能给非负整数排序，如果要拍些许的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数

## 基数排序

* 核心思想： 先按照最后一位来排序手机号码，然后再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序，经过11次排序之后，这样手机号码就有序了
* 使用条件：如果前面急危重，a数已经b数打了，后面几位就不用看了
* 按照每位来排序的算法要是稳定的(即不改变相同数的相对位置)
* 如不同的单词不等长，该如何使用基数排序？
  * 把所有单词补齐到相同长度
* 总结： 需要每一位进行比较，而且位之间是递进关系，如果a的高位数据比b大，那剩下的就不用比较了。且每一位的数据范围不能太大，要可以用线性算法来排序。否则时间复杂度做不到O(n)

## 如何选择合适的排序算法

![3]()

* 一个通用的排序函数，不能选择线性排序算法
* 对小规模数据进行排序，可以选择O(n^2), 如果对大规模数据进行排序，时间复杂度为O(nlogn)更加高效。 所以一般兼顾任意规模的首选复杂度为O(nlogn)

* 归并排序的空间复杂度为O(n),因此使用不如快排广泛，但快排再最快情况下的时间复杂度为O(n^2)，如何解决复杂度恶化的问题？

## 如何优化快排

* 每次分区点都选择最后一个数据，那时间复杂度会退化为O(n^2), 所以出现这种原因是因为分区点选的不够合理
* 最理想的分区点： 被分区点分开的两个分区中，数据的数量差不多

### 常用的两个分区算法

* 三数取中法： 从区间的首，尾，中间，分别取出一个数，然后对比大小，取三个数的中间值作为分区点。如果要排序的数组比较大，可能要"五数取中"或者"十数取中"
* 随机法：每次从要排序的区间中，随机选择一个元素作为分区点