# Binary Tree(二叉树)：
## Key concept
* 没有父节点的节点叫做根节点
* 没有子节点的节点要做叶子节点或者叶节点
* 高度：从下往上算 节点到叶子节点的最长路径(边数)
* 深度：从上往下算 根节点到这个节点所经历的边的个数
* 层数 = 深度+1

## 满二叉树和完全二叉树
* 满二叉树：叶子节点全在最底层，除了叶子节点之外，每个节点都有左右两个节点
* 完全二叉树： 叶子节点都在最底下两层， 最后一层叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树

## 二叉树的存储方法
* 链式存储法： 每个节点有三个字段， 一个存储数据， 另外两个指向左右两个节点的指针。大部分二叉树都是这种结构

![链式存储法](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B3%95.jpg)

* 顺序存储法： 节点X存储在下标为i的位置，左子节点的位置下标为2*i,右子节点的位置下标为2*i+1, 反过来，下标为i/2的位置存储解释它的父节点，完全二叉树就只浪费一个下标为0的点，如果是非完全二叉树，就会浪费比较多

![顺序存储法](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%B3%95.jpg)

顺序存储法浪费节点示意图

![浪费节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%B5%AA%E8%B4%B9%E8%8A%82%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 如果二叉树是一颗完全二叉树， 那用数组存储最好，因为该树不需要存储额外的指针

## 二叉树的遍历

* 前序遍历： 树中的任意节点，1. 打印该节点，2. 打印它的左子树，3.打印它的右子树
* 中序遍历： 对于树中的任意节点， 1.打印它的左子树， 2.打印节点， 3打印它的右子树
* 后序遍历： 树中的任意节点. 1. 打印左子树，2. 打印右子树，3. 打印节点，

**二叉树的前中后序遍历就是一个递归过程**

## 二叉树的时间复杂度

* 每个节点最多被访问两次，所以遍历的时间复杂度与节点个数成正比，即O(n)



## 二叉查找树(Binary search tree)
* 又叫二叉搜索树，可以快速查找一个数据，还支持快速输入， 删除一个数据
* 二叉查找树要求：树中的任意一个节点， 其左子树中的每个节点的值都要小于这个节点的值，而右子树节点的值都大于这个节点的值

![二叉查找树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%B8%89%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 二叉查找树的查找一个节点的操作
    * 先取根节点，如果等于我们要查找的数据，就返回。
    * 查找的数据如果比根节点小，就再左子树中递归查找
    * 查找的数据如果比根节点大，那就再右子树中递归查找

![查找一节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.jpg)

* 二叉查找树的插入操作：新插入的数据一般都是在叶子节点上，所以我们需要从跟节点开始， 依次比较要插入的数据和节点的大小关系
    * 如果插入的数据比节点数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置
    * 如果不为空，就再递归遍历右子树，查找插入位置，反之亦然
    
![二叉查找树的插入操作](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jpg)

## 二叉查找树的删除操作
* 情况1：如果要删除的节点没有子节点，我们只需要直接将其父节点的指针指向null。如节点55
* 情况2：如果要删除的节点只有一个子节点(只有左子节点或右子节点)，就把其父节点的指针指向要删除节点的子节点.如节点13
* 情况3：如果要删除的节点A有两个子节点，找到该节点右子树中的最小节点D。把D替换A位置，然后再删除D节点。

**还有一种简单方法，将要删除的节点标记为已删除，但由于该节点仍在内存中，因此浪费内存空间**

**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)

## 支持重复数据的二叉查找树
* 树中节点存储除了数字，还可以利用键值(key)来构建二叉查找树，对象中的其他字段叫做卫星数据
* 如何处理如果存储的两个对象键值相同：
    * 方法1：通过链表和支持动态扩容的数组等数据结构， 把值相同的数据都存储再同一节点上
    * 方法2：每个节点仍然只存储一个数据，但如果碰到一个节点的值与要插入数据的值相同，就把要插入的数据放到这个节点的右子树即把这个新插入的数据当作大于这个节点的值来处理。
    
    ![插入键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%8F%92%E5%85%A5%E5%AF%B9%E8%B1%A1%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C%E5%A4%84%E7%90%86.jpg)
    
    * 方法2补充说明
        * 要查找数据的时候，如果遇到值相同的节点，不停止，继续在右子树查找，直到叶子节点，才停止。
        
        ![查找键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C%E5%A4%84%E7%90%86.jpg)
        
        * 删除操作，也按上述方法先行查找，再删除
        
        ![删除键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C.jpg)

## 二叉查找树的时间复杂度分析

![三种二查找树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%B8%89%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 第一种相当于链表，查找复杂度就成了O(n)
* 完全二叉树： 除了叶子层，第K层包含的节点个数就是2^(K-1),最后一层的节点个数再1-2^(L-1)之间。
所以 1+2+4+...+2^(L-1)+1  >= n >= 1+2+4+...2^(L-2)+1 所以，完全二叉树的高度小于log(2 n), 而由于两种相差极大，所以一般的二叉查找树不稳定，不适合使用。引出平衡二叉查找树
 
    
## 二叉查找树比散列表的优势
* 散列表无序，而中序遍历二叉查找树就可以达成
* 散列表扩容耗时多，遇到散列冲突，性能不稳定
* 由于哈希冲突的存在以及哈希函数的耗时，效率不一定比平衡二叉树效率高
* 平衡二叉树只用考虑平衡性，而散列表复杂得多


# 平衡二叉查找树：(代表：红黑树)
* 定义： 二叉树中任意一个节点的左右子树的高度相差不能大于1，并且左右两个子树都是一棵平衡二叉树

![平衡二叉树与非平衡二叉树](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg)

[典型代表AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)
* 平衡的意思：让左右看起来相对均衡,让整棵树的高度相对较低。提高插入，删除，查找的效率

## 红黑树(R-B tree)
* 节点被标记为黑色和红色
* 根节点是黑色
* 每个叶子都是黑色的空节点，即叶子不存储数据
* 任何相邻的节点都不能是红色
* 每个节点，从该节点到其可达叶子节点的所有路径，都包含相同数目的黑色节点

![红黑树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

### 为什么说红黑树是近似平衡
* 近似平衡意味着退化不严重
* 二叉树的性能和高度成正比，因此分析红黑树的高度是否能比较稳定的趋近log_2 n
* 将红色节点都删掉，只包含黑色节点的红黑树高度将会比完全二叉树还要小，如图所示，将四叉树的节点放到叶子节点，就变成了完全二叉树(高度为log2 n)
* 加上红色节点，由于红色节点不能相邻，因此最长路径不超过2log_2 n

![删掉红色节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%88%A0%E6%8E%89%E7%BA%A2%E8%89%B2%E8%8A%82%E7%82%B9.jpg)