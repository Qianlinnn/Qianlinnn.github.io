# Binary Tree(二叉树)：
## Key concept
* 没有父节点的节点叫做根节点
* 没有子节点的节点要做叶子节点或者叶节点
* 高度：从下往上算 节点到叶子节点的最长路径(边数)
* 深度：从上往下算 根节点到这个节点所经历的边的个数
* 层数 = 深度+1

## 满二叉树和完全二叉树
* 满二叉树：叶子节点全在最底层，除了叶子节点之外，每个节点都有左右两个节点
* 完全二叉树： 叶子节点都在最底下两层， 最后一层叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树

## 二叉树的存储方法
* 链式存储法： 每个节点有三个字段， 一个存储数据， 另外两个指向左右两个节点的指针。大部分二叉树都是这种结构

![链式存储法](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E6%B3%95.jpg)

* 顺序存储法： 节点X存储在下标为i的位置，左子节点的位置下标为2*i,右子节点的位置下标为2*i+1, 反过来，下标为i/2的位置存储解释它的父节点，完全二叉树就只浪费一个下标为0的点，如果是非完全二叉树，就会浪费比较多

![顺序存储法](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%B3%95.jpg)

顺序存储法浪费节点示意图

![浪费节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%B5%AA%E8%B4%B9%E8%8A%82%E7%82%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 如果二叉树是一颗完全二叉树， 那用数组存储最好，因为该树不需要存储额外的指针

## 二叉树的遍历

* 前序遍历： 树中的任意节点，1. 打印该节点，2. 打印它的左子树，3.打印它的右子树
* 中序遍历： 对于树中的任意节点， 1.打印它的左子树， 2.打印节点， 3打印它的右子树
* 后序遍历： 树中的任意节点. 1. 打印左子树，2. 打印右子树，3. 打印节点，

**二叉树的前中后序遍历就是一个递归过程**

## 二叉树的时间复杂度

* 每个节点最多被访问两次，所以遍历的时间复杂度与节点个数成正比，即O(n)



## 二叉查找树(Binary search tree)
* 又叫二叉搜索树，可以快速查找一个数据，还支持快速输入， 删除一个数据
* 二叉查找树要求：树中的任意一个节点， 其左子树中的每个节点的值都要小于这个节点的值，而右子树节点的值都大于这个节点的值

![二叉查找树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%B8%89%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 二叉查找树的查找一个节点的操作
    * 先取根节点，如果等于我们要查找的数据，就返回。
    * 查找的数据如果比根节点小，就再左子树中递归查找
    * 查找的数据如果比根节点大，那就再右子树中递归查找

![查找一节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.jpg)

* 二叉查找树的插入操作：新插入的数据一般都是在叶子节点上，所以我们需要从跟节点开始， 依次比较要插入的数据和节点的大小关系
    * 如果插入的数据比节点数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置
    * 如果不为空，就再递归遍历右子树，查找插入位置，反之亦然
    
![二叉查找树的插入操作](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jpg)

## 二叉查找树的删除操作
* 情况1：如果要删除的节点没有子节点，我们只需要直接将其父节点的指针指向null。如节点55
* 情况2：如果要删除的节点只有一个子节点(只有左子节点或右子节点)，就把其父节点的指针指向要删除节点的子节点.如节点13
* 情况3：如果要删除的节点A有两个子节点，找到该节点右子树中的最小节点D。把D替换A位置，然后再删除D节点。

**还有一种简单方法，将要删除的节点标记为已删除，但由于该节点仍在内存中，因此浪费内存空间**

**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)

## 支持重复数据的二叉查找树
* 树中节点存储除了数字，还可以利用键值(key)来构建二叉查找树，对象中的其他字段叫做卫星数据
* 如何处理如果存储的两个对象键值相同：
    * 方法1：通过链表和支持动态扩容的数组等数据结构， 把值相同的数据都存储再同一节点上
    * 方法2：每个节点仍然只存储一个数据，但如果碰到一个节点的值与要插入数据的值相同，就把要插入的数据放到这个节点的右子树即把这个新插入的数据当作大于这个节点的值来处理。
    
    ![插入键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%8F%92%E5%85%A5%E5%AF%B9%E8%B1%A1%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C%E5%A4%84%E7%90%86.jpg)
    
    * 方法2补充说明
        * 要查找数据的时候，如果遇到值相同的节点，不停止，继续在右子树查找，直到叶子节点，才停止。
        
        ![查找键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C%E5%A4%84%E7%90%86.jpg)
        
        * 删除操作，也按上述方法先行查找，再删除
        
        ![删除键值相同](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E7%9B%B8%E5%90%8C.jpg)

## 二叉查找树的时间复杂度分析

![三种二查找树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E4%B8%89%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

* 第一种相当于链表，查找复杂度就成了O(n)
* 完全二叉树： 除了叶子层，第K层包含的节点个数就是2^(K-1),最后一层的节点个数再1-2^(L-1)之间。
所以 1+2+4+...+2^(L-1)+1  >= n >= 1+2+4+...2^(L-2)+1 所以，完全二叉树的高度小于log(2 n), 而由于两种相差极大，所以一般的二叉查找树不稳定，不适合使用。引出平衡二叉查找树
 
    
## 二叉查找树比散列表的优势
* 散列表无序，而中序遍历二叉查找树就可以达成
* 散列表扩容耗时多，遇到散列冲突，性能不稳定
* 由于哈希冲突的存在以及哈希函数的耗时，效率不一定比平衡二叉树效率高
* 平衡二叉树只用考虑平衡性，而散列表复杂得多


# 平衡二叉查找树：(代表：红黑树)
* 定义： 二叉树中任意一个节点的左右子树的高度相差不能大于1，并且左右两个子树都是一棵平衡二叉树

![平衡二叉树与非平衡二叉树](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg)

[典型代表AVL树](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)
* 平衡的意思：让左右看起来相对均衡,让整棵树的高度相对较低。提高插入，删除，查找的效率

## 红黑树(R-B tree)
* 节点被标记为黑色和红色
* 根节点是黑色
* 每个叶子都是黑色的空节点，即叶子不存储数据
* 任何相邻的节点都不能是红色
* 每个节点，从该节点到其可达叶子节点的所有路径，都包含相同数目的黑色节点

![红黑树示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

### 为什么说红黑树是近似平衡
* 近似平衡意味着退化不严重
* 二叉树的性能和高度成正比，因此分析红黑树的高度是否能比较稳定的趋近log_2 n
* 将红色节点都删掉，只包含黑色节点的红黑树高度将会比完全二叉树还要小，如图所示，将四叉树的节点放到叶子节点，就变成了完全二叉树(高度为log2 n)
* 加上红色节点，由于红色节点不能相邻，因此最长路径不超过2log_2 n

![删掉红色节点示意图](https://github.com/Qianlinnn/personal-study-zone/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E9%9B%86/%E5%88%A0%E6%8E%89%E7%BA%A2%E8%89%B2%E8%8A%82%E7%82%B9.jpg)

## 实现红黑树的基本思想
* 遇到什么样的节点排布，我们就对应怎么去调整
* 左旋： 围绕某个节点的左旋
* 右旋： 围绕某个节点的右旋

![左旋右旋示意图]()

### 插入操作的平衡调整
* 插入的节点必须是红色的，而且，二叉查找树中新插入的节点都是放在叶子节点上，所以有两种特殊情况：
    * 如果插入节点的父节点是黑色的，什么都不用做
    * 如果插入的是根节点，我们直接改变它的颜色，把它变成黑色
* 调整的操作：左右旋转和改变颜色
    * 关注节点：正在处理的节点
* 调整的三种情况：
    * case 1：如果关注节点是a，它的叔叔节点d是红色， 我们就依次执行下面的操作
        * 将关注节点的父节点和叔节点设置为黑色
        * 将关注节点a的祖父节点c的颜色设置为红色
        * 关注节点变成a的祖父节点c
        * 跳到case 2 or case 3
        
        ![case 1]()
    * case 2: 如果关注节点是a，它的叔叔节点d是黑色，关注节点a是其父节点b的右子节点
        * 关注节点变成a的父节点b
        * 围绕新的关注节点b左旋
        * 跳到case 3
        
        ![case 2]()
        
    * case 3: 如果关注节点是a，它的叔节点d是黑色，关注节点a是其父节点b的左子节点
        * 围绕节点a的祖父节点c右旋；
        * 将关注节点a的父节点b，兄弟节点c的颜色呼唤
        * 调整结束
        
        ![case 3]()
        
 ### 删除操作的平衡调整
* 分为两步 
    * 针对删除节点的初步调整，即保证整棵红黑树在一个节点删除之后，从该节点到其可达到叶子节点的所有路径，都包含相同数目的黑色节点
    * 针对关注节点进行二次调整。 不存在相邻的两个红色节点
  ###
   **如果一个节点既可以是红色，也可以是黑色，一半红一半黑**
    * Case 1：如果要删除的节点是a， 它只有一个子节点b，就进行以下操作：
        * 删除节点a， 并且把节点b替换到节点a的位置。
        * 节点a只能是黑色， 节点b只能是红色。那么该情况下把节点b改为黑色
        * 调整结束。不需二次调整
    
    ![删除节点case1]()
    
    * Case 2: 如果要删除的节点a有两个非空子节点，并且它的后继节点就是a的右子节点c
        * 
    

# 红黑树暂时放弃


## 递归(Recursion)
    * 应用实例： DFS深度优先算法，前中后序二叉树遍历
    * 如：f(n)=f(n-1)+1 f(1)=
    
### 递归需要满足的三个条件
* 一个问题的解可以分解为几个子问题的解(数据规模更小的问题)
* 这个问题与分解之后的子问题，除了数据规模不一样，求解思路完全一样
* 存在递归终止条件

**写出代码的关键是写出递推公式，找到终止条件**

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

### 递归代码要警惕堆栈溢出
* 函数调用是使用栈来保存临时变量，函数执行完成返回时，才出栈，而递归在达到终止条件下会不断保存临时变量。保存变量过多容易导致堆栈溢出
* 避免堆栈溢出的方式是设定一个递归深度值，如1000，超过便直接返回报错。但该方法不实用

### 递归代码要警惕重复计算

![递归重复计算]()

*如该图中，f(5)=f(3)+f(4), f(4)=f(3)+f(2)，其中f(3)就求了2次，因此需要用散列表来保存已经求结果的f(k), 当递归调用f(k)时，看是否求解过
如果是，则直接从散列表中取值。

### 递归的局限性：

* 当函数调用较大时，时间成本较高，且空间复杂度由于内存栈中的积累，所以为O(n)

## 递归树
### 递归树与时间复杂度分析

递归树图示
![]()

归并排序递归树图示

![归并排序递归树]()

* 每次分解的时间消耗量记为1，而归并操作比较耗时，由图可知，每一层的归并操作时间都为n，令树高度为h，时间复杂度为O(n*h)
* 由图也可知，该二叉树为满二叉树，所以时间复杂度为log_2 n, 所以归并排序递归的时间复杂度是O(n) = n*log(n)

### 实际案例

* 用递归树来分析快排的平均情况时间复杂度，假设两个分区的比例大小为1 ：k
    * 取 k = 9，即一个分区是另一个分区的9倍大，如图所示
    
    ![递归树快排分析]()
    
    * 由图可知，每次分区都要遍历带分区区间的所有舒徐，所以，每一层遍历的数据之和为n，只要直到树的高度h，便可知道时间复杂度
    * 根节点到叶子节点的最长路径与最短路径如下图所示
    
    ![最短与最长路径]()
    
    * 所以遍历数据的个数总和： nlog_10 n <=个数<=nlog_(9/10) n. 所以时间复杂度仍然为O(nlogn)

* 分析斐波那契数列的时间复杂度：
       
    ![斐波那契数列递归树图]()
    
    * f(n)分解为f(n-1)和f(n-2),所以最长路径就是每次都-1，路径长度为n，最短路径就是每次-2，路径长度为n/2.
    * 每次分层之后都要进行加法，假设一次相加为1，该层时间消耗与层数关系为t = 2^(k-1)
    * 如果路径长度为n，总和为(2^n) -1 
    * 如果路径长度为n/2，时间消耗综合为 2^(n/2) -1
    * 由以上可知： 算法的时间复杂度为指数级 
     ![路径为n的时间复杂度]()
     
     ![路径为n/2的时间复杂度]()
     
* 分析全排列的时间复杂度，即求n个数据的所有排列组合
    * 该问题可分解为n个"n-1个数据的排列"的子问题
    * 递归树如下
    
    ![全排列递归树图]()
    
    * 由上图可知，第一层分解有n次操作，第二层有n个节点，每个节点要n-1次操作，以此类推最后一层即为n！
    * 所以总次数的表达式为 n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
    * 而前n-1个项都小于最后一个数，所以总和小于n * (n-1)!,即该算法的时间复杂度大于O(n!)，小于O(n*n!)
    
    
     
   

        